#lang racket
(require "microKanren.rkt")
(provide (all-defined-out))
(define succeed (lambda (s/c) (list s/c)))
(define fail (lambda (s/c) `()))
(define (ifte g0 g1 g2)
  (lambda (s/c)
    (let loop (($ (g0 s/c)))
      (cond
        ((procedure? $) (lambda () (loop ($))))
        ((null? $) (g2 s/c))
        (else ($-append-map g1 $))))))
(define (once g)
  (lambda (s/c)
    (let loop (($ (g s/c)))
      (cond
        ((procedure? $) (lambda () (loop ($))))
        ((null? $) `())
        (else (list (car $)))))))
(define (call/project x f)
  (lambda (s/c)
    ((f (walk* x (car s/c)))  s/c)))
(define (walk* v s)
  (let ((v (walk v s)))
    (cond
      ((var? v) v)
      ((pair? v) (cons (walk* (car v) s) (walk* (cdr v) s)))
      (else v))))
