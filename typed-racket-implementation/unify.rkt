#lang typed/racket
(provide (all-defined-out))
(define-type Var Number)
(define-type Term (Rec T (U Symbol Boolean Var Null (Pair T T))))
(: var (-> Number Var))
(define (var n) n)
(: var? (-> Term Boolean))
(define (var? n) (number? n))
(define-type None False)
(struct (a) Some ([v : a]))
(define-type (Opt a) (U None (Some a)))
(define-type Subst (Listof (Pair Term Term)))
(: ext-s (-> Term Term Subst (Some Subst)))
(define (ext-s x v s) (Some `((,x . ,v) . ,s)))
(: walk (-> Term Subst Term))
(define (walk u s)
  (let ((pr (and (var? u) (assv u s))))
    (if pr (walk (cdr pr) s) u)))
(: unify (-> Term Term Subst (Opt Subst)))
(define (unify u v s)
  (let ((u (walk u s)) (v (walk v s)))
    (cond
      ((eqv? u v) (Some s))
      ((var? u) (ext-s u v s))
      ((var? v) (ext-s v u s))
      ((and (pair? u) (pair? v))
       (let ((s (unify (car u) (car v) s))) ;; How to break out of the Some?
         (and s (unify (cdr u) (cdr v) (Some s)))))
      (else #f))))
